<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live GPS Mapping</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }

    button {
      padding: 8px 16px;
      margin: 5px;
      font-size: 14px;
    }

    #status {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>

  <div id="controls">
    <button id="startMapping">üó∫Ô∏è Do Mapping</button>
    <button id="startWalkThrough">üö∂ Walk Through</button>
    <div id="status">Status: Idle</div>
  </div>

  <canvas id="mapCanvas"></canvas>

  <script>
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');

    let watchId;
    let recordedPoints = [];

    // Resize canvas to full screen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function drawPoint(x, y, color = "blue", radius = 5) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    // Scale coordinates to fit canvas nicely with padding
    function scaleCoordinates(coords, width, height, padding = 40) {
      const lats = coords.map(c => c.latitude);
      const lons = coords.map(c => c.longitude);
      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);

      const latRange = maxLat - minLat || 0.0001;
      const lonRange = maxLon - minLon || 0.0001;

      return coords.map(c => ({
        x: padding + ((c.longitude - minLon) / lonRange) * (width - 2 * padding),
        y: height - (padding + ((c.latitude - minLat) / latRange) * (height - 2 * padding)) // Y is reversed
      }));
    }

    function startMapping() {
      localStorage.removeItem('mappedCoordinates');
      recordedPoints = [];
      statusEl.textContent = "Status: Mapping in progress...";

      if (watchId) navigator.geolocation.clearWatch(watchId);

      watchId = navigator.geolocation.watchPosition(
        position => {
          const { latitude, longitude, altitude } = position.coords;
          const point = { latitude, longitude, altitude: altitude || 0 };
          recordedPoints.push(point);
          localStorage.setItem('mappedCoordinates', JSON.stringify(recordedPoints));
          console.log("Mapped Point:", point);
        },
        error => alert("Location error: " + error.message),
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }

    function startWalkThrough() {
      const stored = localStorage.getItem('mappedCoordinates');
      if (!stored) {
        alert("No stored path found. Use 'Do Mapping' first.");
        return;
      }

      const coords = JSON.parse(stored);
      if (coords.length < 2) {
        alert("Insufficient mapped points.");
        return;
      }

      statusEl.textContent = "Status: Showing path and live position...";
      recordedPoints = coords;

      const scaled = scaleCoordinates(coords, canvas.width, canvas.height);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      scaled.forEach(p => drawPoint(p.x, p.y, "blue", 4));

      // Track live position and update canvas
      if (watchId) navigator.geolocation.clearWatch(watchId);

      watchId = navigator.geolocation.watchPosition(
        position => {
          const { latitude, longitude } = position.coords;

          const allPoints = [...coords, { latitude, longitude }];
          const scaledWithLive = scaleCoordinates(allPoints, canvas.width, canvas.height);

          const pathPoints = scaledWithLive.slice(0, -1);
          const currentPoint = scaledWithLive[scaledWithLive.length - 1];

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw path
          pathPoints.forEach(p => drawPoint(p.x, p.y, "blue", 4));

          // Draw current location
          drawPoint(currentPoint.x, currentPoint.y, "red", 6);
        },
        error => alert("Live location error: " + error.message),
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }

    document.getElementById('startMapping').addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }
      startMapping();
    });

    document.getElementById('startWalkThrough').addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }
      startWalkThrough();
    });
  </script>
</body>
</html>
